{% extends "base.html" %}

{% block content %}
<section class="fund-section py-5">
  <div class="fund-wrapper">

    <!-- Personalized Greeting 
    <div class="fund-info">
      <h2 class="fw-bold mb-4">
        Welcome back{% if user %}, {{ user.name }}{% endif %}
      </h2>
      <p class="text-muted">
        This is your personalized investment report.
      </p>
    </div>
-->


    <!-- Left side: Fund Explanation -->
    <div class="fund-info">
      <h2 class="fw-bold mb-4">Vega Core Fund</h2>
      
      <div class="fund-details">
        <h4>Welcome back, Dear {% if investor_name %} {{ investor_name }}{% endif %}</h4>
        <p class="text-muted mb-4 text-justify">
          Thanks for being with us, hear is your personalized investment report.
        </p>

        <h4>Key Features</h4>
        <ul class="list-unstyled">
          <li class="mb-2"><strong>Focus:</strong> Future Market</li>
          <li class="mb-2"><strong>Strategy:</strong> Volatility-Managed Calendar Spread</li>
          <li class="mb-2"><strong>Minimum Investment:</strong> $5000</li>
          <li class="mb-2"><strong>Management Fee:</strong> 2% annually</li>
          <li class="mb-2"><strong>Performance Fee:</strong> 25% of profits above 50% hurdle</li>
        </ul>

        <h4>Performance Metrics</h4>
        <h4>Performance Metrics</h4>
        <div class="metrics-grid">
          <div class="metric-item">
            <span class="metric-label">YTD Portfolio Return:</span>
            <span class="metric-value text-success">‚Äî</span>
          </div>
          <div class="metric-item">
            <span class="metric-label">Portfolio Value (NAV):</span>
            <span class="metric-value">‚Äî</span>
          </div>
          <div class="metric-item">
            <span class="metric-label">Annualized Return:</span>
            <span class="metric-value text-success">‚Äî</span>
          </div>
          <div class="metric-item">
            <span class="metric-label">Locked-In Return:</span>
            <span class="metric-value">‚Äî</span>
          </div>
        </div>

      </div>
    </div>

    <!-- Right side: Interactive Chart -->
    <div class="chart-container">
      <h4>Performance Chart</h4>
      <div class="chart-controls mb-3">
        <div class="row">
          <div class="col-md-4">
            <label for="startDate" class="form-label">Start Date:</label>
            <input type="date" id="startDate" class="form-control" />
          </div>
          <div class="col-md-4">
            <label for="endDate" class="form-label">End Date:</label>
            <input type="date" id="endDate" class="form-control" />
          </div>
          
          <div class="col-md-4 d-flex align-items-end">
          <button id="updateChart" class="btn btn-primary">Update</button>

          <!-- Series dropdown, sits right beside Update -->
          <div class="btn-group ms-2">
          <button id="seriesToggle"
                class="btn btn-outline-secondary dropdown-toggle"
                data-bs-toggle="dropdown"
                aria-expanded="false">
            Indices
          </button>
            <div id="seriesMenu" class="dropdown-menu p-3" style="min-width: 260px; max-height: 300px; overflow:auto;">
              <div class="d-flex justify-content-between mb-2">
                <button id="seriesSelectAll" type="button" class="btn btn-sm btn-link">Select all</button>
                <button id="seriesSelectNone" type="button" class="btn btn-sm btn-link">None</button>
              </div>
              <div id="seriesControls"></div>
            </div>
          </div>
        </div>
        </div>
      </div>
      <div class="chart-area">
        <canvas id="fundChart"></canvas>
      </div>
    </div>
  </div>

  <!-- Second row: Compensation Structure -->
  <div class="fund-wrapper">
    <div class="fund-info">
      <h4 class="fw-bold mb-3">Compensation Structure</h4>
      
        <p class="text-muted text-justify mt-3">
          Our compensation model is designed to align the interests of the fund manager with those of our investors,
          ensuring that meaningful rewards are earned only when we generate exceptional value. The cornerstone of this
          philosophy is the <strong>hurdle rate</strong> ‚Äî a predefined minimum return threshold that must be achieved
          before any performance fees are charged. By setting a high hurdle rate, in our case 40% annually, we create a
          results-driven environment that rewards strategic risk-taking and disciplined execution, while protecting
          investors from paying performance fees during periods of sub-par market conditions. This approach ensures that
          we only participate in profits that represent substantial outperformance beyond the already ambitious benchmark.
        </p>

        <div class="mt-4">
          <ul class="list-group">
            <li class="list-group-item d-flex justify-content-between align-items-center">
              Fixed Management Fee<span>2% annually *</span>
            </li>
            <li class="list-group-item d-flex justify-content-between align-items-center">
              Hurdle Rate<span>50% annually *</span>
            </li>
            <li class="list-group-item d-flex justify-content-between align-items-center">
              Manager‚Äôs Share of Return Above Hurdle<span>25% *</span>
            </li>
          </ul>
        </div>

        <p class="small text-muted mt-3">
          * All parameters are subject to change based on prevailing market conditions, regulatory updates,
          and the fund‚Äôs strategic objectives. Any such changes will be communicated to investors in advance.
          
        </p>
      
    </div>

    <div class="chart-container">
      
        <div class="chart-area" style="height:400px;">
          <canvas id="compensationChart"></canvas>
        </div>
      
    </div>
  </div>
  <!--Thirs row: Compensation Structure -->
  <div class="fund-wrapper">
    <div class="fund-info">
      <h4 class="fw-bold mb-3">Performance Reporting</h4>
      
        <p class="text-muted text-justify mt-3">
          Investor returns are reported on a money-weighted IRR basis, calculated from each investor‚Äôs
           contribution cash flows and terminal portfolio value. Fund-level performance is presented
            using time-weighted returns for comparability with benchmarks.Performance fees are assessed
             <strong>per contribution</strong> under a hard hurdle with whole-return sharing. For each subscription,
              fees apply only if the realized return exceeds the hurdle rate. When this occurs, the
               investor retains the greater of the hurdle rate or 75% of the total return, with the
                fund receiving the balance. If performance falls below the hurdle, no performance
                 fee is charged. This contribution-based structure ensures that new investments are never
                  charged on performance earned before their entry, while the hard hurdle provides
                   investors with downside protection and aligns compensation with realized results.
                   <br><br>
                   On the right, contributions are shown as negative cash flows at their dates; the terminal portfolio value
                   (latest NAV in the selected window) is shown as a positive cash flow. 
        </p>
    </div>

    <div class="chart-container">
      <div class="chart-area" style="height:320px;">
        <canvas id="cashFlowChart"></canvas>
      </div>
    </div>
  </div>
</section>


<!-- Chart.js & Moment.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>

<script>
let fundChart;
let cashFlowChart;
let csvRows = [];
let seriesNames = [];
const EXTRA_SERIES_KEY = "Fund (After Fee)";
let selectedSeries = new Set();  // which series user wants visible



//          

















// Detect delimiter
function detectDelimiter(headerLine) {
  const cands = [',',';','\t','|'];
  let best = ',', bestCount = 0;
  for (const d of cands) {
    const c = headerLine.split(d).length - 1;
    if (c > bestCount) { best = d; bestCount = c; }
  }
  return best;
}

// Parse number with localization and % handling
function parseNumber(s) {
  if (s == null) return NaN;
  s = String(s).trim().replace(/^\uFEFF/, '').replace(/\u00A0/g, '');
  let hadPercent = /%/.test(s);
  s = s.replace(/%/g, '');
  const hasComma = s.includes(','), hasDot = s.includes('.');
  if (hasComma && hasDot) {
    if (s.lastIndexOf(',') > s.lastIndexOf('.')) s = s.replace(/\./g,'').replace(',', '.');
    else s = s.replace(/,/g,'');
  } else if (hasComma) {
    s = s.replace(',', '.');
  }
  let v = parseFloat(s);
  if (!isFinite(v)) return NaN;
  if (hadPercent) v = v / 100;
  return v;
}

// Parse CSV with fixed column indexes
function parseCSVMulti(csvText) {
  const lines = csvText.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
  if (lines.length < 2) throw new Error('CSV appears empty');

  const headerRaw = lines[0].replace(/^\uFEFF/, '');
  const delim = detectDelimiter(headerRaw);

  const dateCol = 0; // First column is date
  const colIndexes = [
    { name: 'Accumulated Return', idx: 1 },
    { name: 'Bourse Index', idx: 2 },
    { name: 'Gold Index', idx: 3 },
    { name: 'Dollar Index', idx: 4 }

    
  ];

  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const parts = lines[i].split(delim);
    const dRaw = parts[dateCol]?.trim();
    if (!dRaw) continue;

    const dt = new Date(dRaw);
    const iso = isNaN(dt.getTime()) ? dRaw : dt.toISOString().split('T')[0];

    const rec = { date: iso, series: {} };
    colIndexes.forEach(col => {
      const v = parseNumber(parts[col.idx]);
      rec.series[col.name] = isFinite(v) ? v : null;
    });
    rows.push(rec);
  }

  rows.sort((a,b) => (a.date < b.date ? -1 : 1));
  return { rows, names: colIndexes.map(c => c.name) };
}

function firstValid(arr) {
  for (const x of arr) {
    if (x != null && isFinite(x)) return x;
  }
  return null;
}

async function loadCSVDataForChart() {
  try {
    const investorEmail = "{{ investor_email }}";
    const safeFileName = investorEmail.replace(/@/g, '-').replace(/\./g, '-') + "-data.csv";
    const filePath = `/static/${safeFileName}`;

    const resp = await fetch(filePath, { cache: 'no-store' });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

    const text = await resp.text();
    const parsed = parseCSVMulti(text);
    csvRows = parsed.rows;
    seriesNames = parsed.names;
     
      // üõ† Debug logs
    console.log("CSV loaded from:", filePath);
    console.log("Number of rows loaded:", csvRows.length);
    console.log("Series names parsed:", seriesNames);
 
  
       // build the dropdown now that we have seriesNames
    renderSeriesControls();

    if (!csvRows.length || !seriesNames.length) {
      throw new Error('No usable chart data/series found');
    }

    

    const todayStr = new Date().toISOString().split('T')[0];
    document.getElementById('startDate').value = csvRows[0].date;
    document.getElementById('endDate').value = todayStr;

    updateChart();
  } catch (err) {
    console.error('Error loading/parsing chart CSV:', err);
    alert('Could not read chart CSV file.');
  }
}

function filterByDate(startDate, endDate) {
  const s = new Date(startDate);
  const e = new Date(endDate);
  if (isNaN(s) || isNaN(e)) return [];
  return csvRows.filter(r => {
    const t = new Date(r.date);
    return !isNaN(t) && t >= s && t <= e;
  });
}

function rebaseSeries(values) {
  const base = firstValid(values);
  if (base == null || !isFinite(base) || base <= -1) return values.map(_ => null);
  return values.map(v => (v == null || !isFinite(v)) ? null : (((1 + v) / (1 + base)) - 1) * 100);
}

function updateChart() {
  const startDate = document.getElementById('startDate').value;
  const endDate   = document.getElementById('endDate').value;
  if (!startDate || !endDate || !csvRows.length) return;

  const rows = filterByDate(startDate, endDate);
  if (!rows.length) return;

  const labels = rows.map(r => r.date);
  const datasets = [];
  const palette = ['#0d6efd','#dc3545','#198754','#fd7e14','#6f42c1','#20c997'];

  // helper: is this series currently selected?
  const want = (name) => selectedSeries.has(name);

  // robust fund detection (kept from your version)
  const FUND_ALIASES = ['fund','vega core fund','vega fund','core fund','vega'];
  const isFund = (name, idx) => {
    const n = String(name || '').toLowerCase().trim();
    return FUND_ALIASES.some(a => n === a || n.includes(a)) || idx === 0;
  };

  // fee params
  const start = new Date(startDate);
  const mYear = 0.02; // management 2% p.a.
  const hYear = 0.5; // hurdle 40% p.a.
  let fundAfterFee = null;

  seriesNames.forEach((name, i) => {
    const raw = rows.map(r => r.series[name]);
    const rebasedPct = rebaseSeries(raw);

    // compute after-fee off the fund (even if hidden, so it can be toggled on without recomputation)
    if (isFund(name, i)) {
      fundAfterFee = rebasedPct.map((ret, idx) => {
        const currentDate = new Date(rows[idx].date);
        const T = (currentDate - start) / 86400000; // days since start
        const m_T = Math.pow(1 + mYear, T / 365) - 1;
        const h_T = Math.pow(1 + hYear, T / 365) - 1;

        let investorRet;
        console.log("Index:", idx, "Raw ret value:", ret, "Type:", typeof ret);
        console.log("Index:", idx, "HT value:", h_T, "Type:", typeof ret);
        if (ret/100 > h_T) {
          investorRet = Math.max(h_T, 0.75 * ret);
        } else {
          investorRet = ret;
        }
        return investorRet - m_T*100;
      });
    }

    // only plot if this series is selected
    if (want(name)) {
      datasets.push({
        label: name,
        data: rebasedPct,
        borderWidth: 0.5,
        tension: 0.1,
        borderColor: palette[datasets.length % palette.length],
        backgroundColor: 'rgba(0,0,0,0)',
        spanGaps: true,
        pointRadius: 0.5,
        pointHoverRadius: 0.5
      });
    }
  });

  // add extra line only if selected
  if (Array.isArray(fundAfterFee) && want(EXTRA_SERIES_KEY)) {
    datasets.push({
      label: EXTRA_SERIES_KEY,
      data: fundAfterFee,
      borderWidth: 0.5,
      tension: 0.1,
      borderColor: palette[datasets.length % palette.length],
      backgroundColor: 'rgba(0,0,0,0)',
      spanGaps: true,
      pointRadius: 0.5,
      pointHoverRadius: 0.5
    });
  }

  // if user deselects everything, keep chart alive but empty data
  const ctx = document.getElementById('fundChart').getContext('2d');
  if (fundChart) fundChart.destroy();
  fundChart = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { title: { display: true, text: 'Date' } },
        y: {
          title: { display: true, text: 'Return since start (%)' },
          ticks: { callback: v => v.toFixed(1) + '%' }
        }
      },
      plugins: {
        title: { display: true, text: 'Vega Core Fund ‚Äî Rebased Performance (Selected Window)' },
        legend: { display: true, position: 'top' },
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y != null ? ctx.parsed.y.toFixed(2) + '%' : '‚Äî'}`
          }
        }
      }
    }
  });
}

function computeXIRR(cashflows, guess = 0.1) {
  // cashflows: array of {date: Date, value: number}
  const maxIter = 100, tol = 1e-7;
  let rate = guess;

  for (let iter = 0; iter < maxIter; iter++) {
    let f = 0, df = 0;
    const t0 = cashflows[0].date;

    for (const {date, value} of cashflows) {
      const days = (date - t0) / (1000 * 60 * 60 * 24);
      const frac = days / 365.0;
      const denom = Math.pow(1 + rate, frac);
      f += value / denom;
      df += -(frac * value) / (denom * (1 + rate));
    }

    const newRate = rate - f / df;
    if (Math.abs(newRate - rate) < tol) return newRate;
    rate = newRate;
  }
  return rate;
}


async function loadCashFlowChart() {
  try {
    const investorEmail = "{{ investor_email }}";
    const safeFileName  = investorEmail.replace(/@/g, '-').replace(/\./g, '-') + "-data.csv";
    const filePath      = `/static/${safeFileName}`;

    const resp = await fetch(filePath, { cache: 'no-store' });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();

    // Parse CSV
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
    if (lines.length < 2) throw new Error('CSV appears empty');
    const delim = detectDelimiter(lines[0]);
    const rows  = lines.slice(1).map(l => l.split(delim));

    console.log(`CF CSV loaded: ${rows.length} rows`);

    // Hardcoded indices: 0=date, 7=asset, 8=contribution
    const cfRows = rows.map((r, idx) => {
      const d  = new Date(r[0]);
      const ds = isNaN(d.getTime()) ? r[0] : d.toISOString().split('T')[0];

      const asset       = parseNumber(r[7]);
      const contribRaw  = parseNumber(r[8]);

      return {
        date: ds,
        asset: isFinite(asset) ? asset : NaN,
        contrib: isFinite(contribRaw) ? -Math.abs(contribRaw) : 0
      };
    });

    // Ensure date inputs are set before drawing
    const startEl = document.getElementById('startDate');
    const endEl   = document.getElementById('endDate');
    if (startEl && !startEl.value && cfRows.length) startEl.value = cfRows[0].date;
    if (endEl   && !endEl.value   && cfRows.length) endEl.value   = cfRows[cfRows.length - 1].date;

    console.log(`CF date window init: ${startEl?.value} ‚Üí ${endEl?.value}`);

    // === Chart render ===
    function renderCFChart(cfRows) {
      let xirr = NaN;   // <-- define here, top of function
      const s = new Date(startEl?.value);
      const e = new Date(endEl?.value);
      if (!(s instanceof Date) || !(e instanceof Date)) return;
      

      const win = cfRows.filter(r => {
        const t = new Date(r.date);
        return !isNaN(t) && t >= s && t <= e;
      });
      if (win.length === 0) return;

      const labels = [];
      const contribs = [];
      const mgmtFees = [];
      const perfFees = [];
      const residuals = [];

      // Parameters
      const mYear = 0.02;  // 2% management fee annual
      const hYear = 0.5;  // hurdle example: 5% annual

      // Contributions shown as negative bars
      win.forEach(r => {
        if (isFinite(r.contrib) && Math.abs(r.contrib) > 0) {
          labels.push(r.date);
          contribs.push(r.contrib);
          mgmtFees.push(0);
          perfFees.push(0);
          residuals.push(0);
        }
      });

      // === Use endDate as "current date" ===
      const currentDate = new Date(); // always use today
      // Find asset value at or before currentDate
      const todayRow = [...cfRows].reverse().find(r => {
        const d = new Date(r.date);
        return !isNaN(d) && d <= currentDate && isFinite(r.asset) && r.asset > 0;
      });

      if (todayRow) {
        let totalMgmt = 0, totalPerf = 0;

        // For each contribution, compute fees up to current date
        cfRows.forEach((r, idx) => {
          if (r.contrib < 0) {
            const contribDate = new Date(r.date);
            if (contribDate <= currentDate) {
              const T = (currentDate - contribDate) / (1000 * 60 * 60 * 24); // days
              const m_T = Math.pow(1 + mYear, T / 365) - 1;
              const h_T = Math.pow(1 + hYear, T / 365) - 1;

              // Find return at current (end date or nearest before)
              const currentRow = [...rows].reverse().find(rr => {
                const d = new Date(rr[0]);
                return !isNaN(d) && d <= currentDate;
              });
              const retAtCurrent = currentRow ? parseNumber(currentRow[1]) : NaN;

              // Return at contribution
              
              const retAtContrib = parseNumber(rows[idx][1]);
              if (!isFinite(retAtCurrent) || !isFinite(retAtContrib)) return;

              const Ret = (1 + retAtCurrent) / (1 + retAtContrib) - 1;

              let investorRet;
              if (Ret > h_T) {
                investorRet = Math.max(h_T, 0.75 * Ret);
              } else {
                investorRet = Ret;
              }

              const base = Math.abs(r.contrib);
              const mgmtFee = base * m_T;
              const perfFee = base * (Ret-investorRet);
              console.log(
                `‚úÖ Contribution @ ${r.date} | T=${T.toFixed(1)} days | base=${base.toFixed(2)}| retAtContrib=${retAtContrib.toFixed(4)} |
                 retAtCurrent=${retAtCurrent.toFixed(4)} | investorRet=${investorRet.toFixed(4)}| Ret=${Ret.toFixed(4)} | h_T=${h_T.toFixed(4)} | m_T=${m_T.toFixed(4)} |MgmtFee=${mgmtFee.toFixed(2)} 
                   | PerfFee=${perfFee.toFixed(2)}`
              );


              totalMgmt += mgmtFee;
              totalPerf += perfFee;
            }
          }
        });

        const residual = todayRow.asset - totalMgmt - totalPerf;
        // === XIRR calculation ===
          // === XIRR calculation ===
        const cfSeries = [];

        // Contributions (negative)
        cfRows.forEach(r => {
          if (isFinite(r.contrib) && r.contrib !== 0) {
            cfSeries.push({ date: new Date(r.date), value: r.contrib });
          }
        });

        // Terminal value (positive)
        cfSeries.push({ date: currentDate, value: residual });
        // üîç Debug logs
        console.log("CF Series for XIRR:");
        cfSeries.forEach(cf => {
          console.log(`   ${cf.date.toISOString().split('T')[0]} | ${cf.value}`);
        });
        // Compute XIRR
        
        try {
          xirr = computeXIRR(cfSeries) * 100; // percent
          console.log(`üìà XIRR = ${xirr.toFixed(2)}%`);
        } catch (err) {
          console.error("XIRR failed:", err);
        }





        // === Terminal stacked bar ===
        labels.push("Terminal");
        contribs.push(0);
        mgmtFees.push(totalMgmt);
        perfFees.push(totalPerf);
        residuals.push(residual);
      }

      const ctx = document.getElementById('cashFlowChart').getContext('2d');
      if (cashFlowChart) cashFlowChart.destroy();
      console.log("üéØ Final XIRR before chart build:", xirr);
      cashFlowChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [
          {
            label: 'Contributions',
            data: contribs,
            backgroundColor: 'rgba(220,53,69,0.7)',
            stack: 'stack1',
            order: 1
          },
          {
            label: 'Investor Share',
            data: residuals,
            backgroundColor: 'rgba(25,135,84,0.7)',
            stack: 'stack1',
            order: 2
          },
          {
            label: 'Perf Fee',
            data: perfFees,
            backgroundColor: 'rgba(13,110,253,0.7)',
            stack: 'stack1',
            order: 3
          },
          {
            label: 'Mgmt Fee',
            data: mgmtFees,
            backgroundColor: 'rgba(255,193,7,0.7)',
            stack: 'stack1',
            order: 4
          }
        ]
        },
        
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: { display: true, text: `Cash Flows, Fees & Terminal Value (XIRR: ${isFinite(xirr) ? xirr.toFixed(2)+'%' : 'n/a'})`  },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const v = ctx.parsed.y;
                  return `${ctx.dataset.label}: ${Number(v).toLocaleString()}`;
                }
              }
            }
          },
          scales: {
            x: { stacked: true },
            y: { stacked: true }
          }
        }
      });
    }

    // Initial render
    renderCFChart(cfRows);

    // Hook listeners
    ['startDate','endDate'].forEach(id => {
      const el = document.getElementById(id);
      if (el && !el.dataset.cfHooked) {
        el.addEventListener('change', () => renderCFChart(cfRows));
        el.dataset.cfHooked = '1';
      }
    });
    const updBtn = document.getElementById('updateChart');
    if (updBtn && !updBtn.dataset.cfHooked) {
      updBtn.addEventListener('click', () => renderCFChart(cfRows));
      updBtn.dataset.cfHooked = '1';
    }
  } catch (e) {
    console.error('‚ùå Cash flow chart error:', e);
  }
}

// Filter, build series, and draw bars
function updateCFChart(cfRows) {
  if (!Array.isArray(cfRows) || cfRows.length === 0) return;

  const startDate = document.getElementById('startDate')?.value;
  const endDate   = document.getElementById('endDate')?.value;
  if (!startDate || !endDate) return;

  const s = new Date(startDate);
  const e = new Date(endDate);

  // Filter by date window
  const win = cfRows.filter(r => {
    const t = new Date(r.date);
    return !isNaN(t) && t >= s && t <= e;
  });
  if (win.length === 0) return;

  // Build labels & data: contributions (as negative), then a final "Terminal" bar with NAV
  const labels = [];
  const data   = [];

  win.forEach(r => {
    // Only show non-zero contributions
    if (isFinite(r.contrib) && Math.abs(r.contrib) > 0) {
      labels.push(r.date);
      // Force negative sign for contributions
      data.push(-Math.abs(r.contrib));
    }
  });

  // Terminal value: last available NAV in window
  const lastWithAsset = [...win].reverse().find(r => isFinite(r.asset) && r.asset !== 0);
  if (lastWithAsset) {
    labels.push('Terminal');
    data.push(lastWithAsset.asset);
  }

  const ctx = document.getElementById('cashFlowChart').getContext('2d');
  if (cashFlowChart) cashFlowChart.destroy();

  cashFlowChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label: 'Cash Flows',
        data,
        backgroundColor: (ctx) => {
          const v = ctx.raw;
          // negative (contrib) vs positive (terminal)
          return v < 0 ? 'rgba(220,53,69,0.7)' : 'rgba(25,135,84,0.7)';
        },
        borderWidth: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { title: { display: true, text: 'Date / Terminal' } },
        y: {
          title: { display: true, text: 'Cash Flow (absolute currency units)' },
          ticks: {
            callback: (v) => {
              try { return Number(v).toLocaleString(); } catch { return v; }
            }
          }
        }
      },
      plugins: {
        legend: { display: false },
        title: { display: true, text: 'Contribution Cash Flows & Terminal Value' },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const v = ctx.parsed.y;
              const lbl = v < 0 ? 'Contribution' : 'Terminal';
              const fmt = (() => { try { return Number(v).toLocaleString(); } catch { return v; }})();
              return `${lbl}: ${fmt}`;
            }
          }
        }
      }
    }
  });
}


async function loadCSVDataForMetrics() {
  try {
    const investorEmail = "{{ investor_email }}";
    const safeFileName = investorEmail.replace(/@/g, '-').replace(/\./g, '-') + "-data.csv";
    const filePath = `/static/${safeFileName}`;
    console.log("üîç Fetching metrics CSV from:", filePath);

    const resp = await fetch(filePath, { cache: 'no-store' });
    console.log("‚úÖ Response status:", resp.status);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

    const text = await resp.text();
    console.log("üìÑ CSV Raw Text:\n", text);

    const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
    console.log("üìä Line count (incl header):", lines.length);

    if (lines.length < 2) {
      console.warn("‚ö†Ô∏è CSV file empty or invalid.");
      return;
    }

    const delim = detectDelimiter(lines[0]);
    console.log("üõ† Detected delimiter:", JSON.stringify(delim));

    const rows = lines.slice(1).map(l => l.split(delim));
    console.log("üìã Parsed data rows count:", rows.length);

    const todayStr = new Date().toISOString().split('T')[0];
    console.log("üìÖ Today ISO:", todayStr);

    const safeGet = (row, idx) => (row && row.length > idx) ? parseNumber(row[idx]) : NaN;

    // 1Ô∏è‚É£ Find today's index
    let todayIndex = rows.findIndex(r => {
      const d = new Date(r[0]);
      return !isNaN(d) && d.toISOString().split('T')[0] === todayStr;
    });
    console.log("üìç Initial todayIndex:", todayIndex);

    if (todayIndex === -1) {
      console.log("‚ö†Ô∏è Today not found, searching for last past date");
      todayIndex = rows.findIndex(r => {
        const d = new Date(r[0]);
        return !isNaN(d) && d <= new Date();
      });
      if (todayIndex === -1) todayIndex = rows.length - 1;
    }
    console.log("üìç Final todayIndex:", todayIndex, "Date:", rows[todayIndex]?.[0]);

    // 2Ô∏è‚É£ Backward search for YTD, Annualized, NAV
    const findValidBackwards = (startIndex, colIdx, label) => {
      for (let i = startIndex; i >= 0; i--) {
        const val = safeGet(rows[i], colIdx);
        console.log(`üîé Check ${label} @ row ${i}, date ${rows[i][0]} ‚Üí`, val);
        if (isFinite(val) && val !== 0) {
          console.log(`‚úÖ Found valid ${label} @ row ${i}`, val);
          return { val, idx: i };
        }
      }
      console.log(`‚ùå No valid ${label} found backwards from index ${startIndex}`);
      return { val: NaN, idx: null };
    };

    const ytdInfo = findValidBackwards(todayIndex, 5, "YTD");
    const annInfo = findValidBackwards(todayIndex, 6, "Annualized");
    const navInfo = findValidBackwards(todayIndex, 7, "NAV");

    // 3Ô∏è‚É£ Locked Base is always from the latest date in the file
    const latestRowIndex = rows.length - 1;
    const latestRow = rows[latestRowIndex];
    const lockedBase = safeGet(latestRow, 1);
    const lockedDate = new Date(latestRow[0]);

    console.log("üìå Locked Base:", lockedBase, "Locked Date:", lockedDate.toISOString().split('T')[0]);

    const daysDiff = Math.abs((lockedDate - new Date()) / 86400000);
    console.log("üìÜ Days diff (Locked Date - Today):", daysDiff);

    let lockedIn = null;
    if (isFinite(lockedBase) && isFinite(ytdInfo.val) && daysDiff > 0) {
      lockedIn = Math.pow((1 + lockedBase) / (1 + ytdInfo.val), 365 / daysDiff) - 1;
    }
    console.log("üîí LockedIn computed:", lockedIn);

    // 4Ô∏è‚É£ Update DOM
    const metricEls = document.querySelectorAll('.metric-item .metric-value');
    console.log("üñä Found metric elements:", metricEls.length);

    if (isFinite(ytdInfo.val)) metricEls[0].textContent = (ytdInfo.val * 100).toFixed(2) + '%';
    if (isFinite(navInfo.val)) metricEls[1].textContent = navInfo.val.toLocaleString();
    if (isFinite(annInfo.val)) metricEls[2].textContent = (annInfo.val * 100).toFixed(2) + '%';
    if (isFinite(lockedIn))    metricEls[3].textContent = (lockedIn * 100).toFixed(2) + '%';

  } catch (err) {
    console.error('‚ùå Performance metric error:', err);
  }
}
function renderSeriesControls() {
  const container = document.getElementById('seriesControls');

  // Hard fail if the node isn't in DOM
  if (!container) {
    console.error("renderSeriesControls: #seriesControls not found");
    return;
  }

  const allSeries = [...seriesNames, EXTRA_SERIES_KEY];
  console.log("renderSeriesControls: allSeries =", allSeries);

  // If nothing to show, render a placeholder so the menu isn't visually empty
  if (!allSeries.length) {
    container.innerHTML = '<div class="text-muted small">No series loaded</div>';
    return;
  }

  // initialize once
  if (selectedSeries.size === 0) {
    allSeries.forEach(s => selectedSeries.add(s));
  }

  container.innerHTML = '';
  allSeries.forEach((name, idx) => {
    try {
      const id = `series-${idx}`;
      const row = document.createElement('div');
      row.className = 'form-check mb-1';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.className = 'form-check-input';
      cb.id = id;
      cb.checked = selectedSeries.has(name);
      cb.addEventListener('change', () => {
        if (cb.checked) selectedSeries.add(name);
        else selectedSeries.delete(name);
        updateChart();
      });

      const label = document.createElement('label');
      label.className = 'form-check-label';
      label.setAttribute('for', id);
      label.textContent = name;

      row.appendChild(cb);
      row.appendChild(label);
      container.appendChild(row);
    } catch (e) {
      console.error("renderSeriesControls: error for", name, e);
    }
  });

  const btnAll  = document.getElementById('seriesSelectAll');
  const btnNone = document.getElementById('seriesSelectNone');
  if (btnAll) btnAll.onclick = () => { selectedSeries = new Set(allSeries); renderSeriesControls(); updateChart(); };
  if (btnNone) btnNone.onclick = () => { selectedSeries.clear(); renderSeriesControls(); updateChart(); };
}
['startDate','endDate'].forEach(id =>
  document.getElementById(id).addEventListener('change', updateChart)
);
document.getElementById('updateChart').addEventListener('click', updateChart);
window.addEventListener('load', async () => {
  // Load chart independently
  await loadCSVDataForChart();
  // Load metrics independently
  await loadCSVDataForMetrics();
});
window.addEventListener('load', () => {
  console.log('üîî loadCashFlowChart() starting‚Ä¶');
  loadCashFlowChart();
});

document.addEventListener('DOMContentLoaded', () => {
  const toggle = document.getElementById('seriesToggle');
  if (toggle) {
    toggle.addEventListener('shown.bs.dropdown', () => {
      console.log("Dropdown opened ‚Äî re-rendering series controls");
      renderSeriesControls();
    });
  }
});

</script>













<!-- Chart.js -->

<script>
document.addEventListener('DOMContentLoaded', async () => {
  const compCanvas = document.getElementById('compensationChart');
  
  try {
    const resp = await fetch('{{ url_for("static", filename="compensation.csv") }}', { cache: 'no-store' });
    const text = await resp.text();
    const rows = text.trim().split(/\r?\n/).map(r => r.split(','));

    const labels         = rows.slice(1).map(r => r[0]);          // First col = total return label
    const investorReturn = rows.slice(1).map(r => parseFloat(r[1])); // Col 2 = investor return
    const fundFee        = rows.slice(1).map(r => parseFloat(r[2])); // Col 3 = management fee

    new Chart(compCanvas.getContext('2d'), {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { 
            label: 'Investor Return', 
            data: investorReturn, 
            backgroundColor: 'rgba(54, 162, 235, 0.7)',
            stack: 'combined'
          },
          { 
            label: 'Fund Fee', 
            data: fundFee, 
            backgroundColor: 'rgba(255, 159, 64, 0.7)',
            stack: 'combined'
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { 
            stacked: true,
            title: { display: true, text: 'Total Return' }
          },
          y: { 
            stacked: true,
            beginAtZero: true,
            ticks: { callback: v => v + '%' }
          }
        },
        plugins: {
          legend: { position: 'top' },
          title: { display: true, text: 'Compensation vs Investor Return (Stacked)' },
          tooltip: {
            callbacks: {
              label: function(context) {
                return `${context.dataset.label}: ${context.parsed.y}%`;
              }
            }
          }
        }
      }
    });

  } catch (e) {
    console.error('Failed to load compensation.csv', e);
  }
});
</script>

{% endblock %}
