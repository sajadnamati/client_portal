{% extends "base.html" %}

{% block content %}
<section class="fund-section py-5">
  <div class="fund-wrapper">

    <!-- Personalized Greeting 
    <div class="fund-info">
      <h2 class="fw-bold mb-4">
        Welcome back{% if user %}, {{ user.name }}{% endif %}
      </h2>
      <p class="text-muted">
        This is your personalized investment report.
      </p>
    </div>
-->


    <!-- Left side: Fund Explanation -->
    <div class="fund-info">
      <h2 class="fw-bold mb-4">Vega Core Fund</h2>
      
      <div class="fund-details">
        <h4>Welcome back, Dear {% if investor_name %} {{ investor_name }}{% endif %}</h4>
        <p class="text-muted mb-4 text-justify">
          Thanks for being with us, hear is your personalized investment report.
        </p>

        <h4>Key Features</h4>
        <ul class="list-unstyled">
          <li class="mb-2"><strong>Focus:</strong> Future Market</li>
          <li class="mb-2"><strong>Strategy:</strong> Volatility-Managed Calendar Spread</li>
          <li class="mb-2"><strong>Minimum Investment:</strong> $5000</li>
          <li class="mb-2"><strong>Management Fee:</strong> 2% annually</li>
          <li class="mb-2"><strong>Performance Fee:</strong> 25% of profits above 50% hurdle</li>
        </ul>

        
        <h4>Performance Metrics</h4>
          <div class="metrics-grid">
            <div class="metric-item">
              <span class="metric-label">YTD Fund Return (Before fees):</span>
              <span class="metric-value text-success">
                {% if metrics.ytd_return %}{{ (metrics.ytd_return * 100) | round(2) }}%{% else %}—{% endif %}
              </span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Your Portfolio Value (NAV):</span>
              <span class="metric-value">
                {% if metrics.portfolio_value_nav %}
                  {{ "{:,.0f}".format(metrics.portfolio_value_nav) }} IRR
                {% else %}
                  —
                {% endif %}
              </span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Annualized Return (IRR) of your Investment:</span>
              <span class="metric-value text-success">
                {% if metrics.irr %}{{ (metrics.irr * 100) | round(2) }}%{% else %}—{% endif %}
              </span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Locked-In Return Ahead:</span>
              <span class="metric-value">
                {% if metrics.locked_in_return %}{{ (metrics.locked_in_return * 100) | round(2) }}%{% else %}—{% endif %}
              </span>
            </div>
          </div>

      </div>
    </div>

    <!-- Right side: Interactive Chart -->
    <div class="chart-container">
      <h4>Performance Chart</h4>
      <div class="chart-controls mb-3">
        <div class="row">
          <div class="col-md-4">
            <label for="startDate" class="form-label">Start Date:</label>
            <input type="date" id="startDate" class="form-control" />
          </div>
          <div class="col-md-4">
            <label for="endDate" class="form-label">End Date:</label>
            <input type="date" id="endDate" class="form-control" />
          </div>
          
          <div class="col-md-4 d-flex align-items-end">
          <button id="updateChart" class="btn btn-primary">Update</button>

          <!-- Series dropdown, sits right beside Update -->
          <div class="btn-group ms-2">
          <button id="seriesToggle"
                class="btn btn-outline-secondary dropdown-toggle"
                data-bs-toggle="dropdown"
                aria-expanded="false">
            Indices
          </button>
            <div id="seriesMenu" class="dropdown-menu p-3" style="min-width: 260px; max-height: 300px; overflow:auto;">
              <div class="d-flex justify-content-between mb-2">
                <button id="seriesSelectAll" type="button" class="btn btn-sm btn-link">Select all</button>
                <button id="seriesSelectNone" type="button" class="btn btn-sm btn-link">None</button>
              </div>
              <div id="seriesControls"></div>
            </div>
          </div>
        </div>
        </div>
      </div>
      <div class="chart-area">
        <canvas id="fundChart"></canvas>
      </div>
    </div>
  </div>

  <!-- Second row: Compensation Structure -->
  <div class="fund-wrapper">
    <div class="fund-info">
      <h4 class="fw-bold mb-3">Compensation Structure</h4>
      
        <p class="text-muted text-justify mt-3">
          Our compensation model is designed to align the interests of the fund manager with those of our investors,
          ensuring that meaningful rewards are earned only when we generate exceptional value. The cornerstone of this
          philosophy is the <strong>hurdle rate</strong> — a predefined minimum return threshold that must be achieved
          before any performance fees are charged. By setting a high hurdle rate, in our case 40% annually, we create a
          results-driven environment that rewards strategic risk-taking and disciplined execution, while protecting
          investors from paying performance fees during periods of sub-par market conditions. This approach ensures that
          we only participate in profits that represent substantial outperformance beyond the already ambitious benchmark.
        </p>

        <div class="mt-4">
          <ul class="list-group">
            <li class="list-group-item d-flex justify-content-between align-items-center">
              Fixed Management Fee<span>2% annually *</span>
            </li>
            <li class="list-group-item d-flex justify-content-between align-items-center">
              Hurdle Rate<span>50% annually *</span>
            </li>
            <li class="list-group-item d-flex justify-content-between align-items-center">
              Manager’s Share of Return Above Hurdle<span>25% *</span>
            </li>
          </ul>
        </div>

        <p class="small text-muted mt-3">
          * All parameters are subject to change based on prevailing market conditions, regulatory updates,
          and the fund’s strategic objectives. Any such changes will be communicated to investors in advance.
          
        </p>
      
    </div>

    <div class="chart-container">
      <h4>Compensation Chart</h4>
        <div class="chart-area" style="height:400px;">
          <canvas id="compensationChart"></canvas>
        </div>
      
    </div>
  </div>
  <!--Thirs row: Compensation Structure -->
  <div class="fund-wrapper">
    <div class="fund-info">
      <h4 class="fw-bold mb-3">Performance Reporting</h4>
      
        <p class="text-muted text-justify mt-3">
          Investor returns are reported on a money-weighted IRR basis, calculated from each investor’s
           contribution cash flows and terminal portfolio value. Fund-level performance is presented
            using time-weighted returns for comparability with benchmarks.Performance fees are assessed
             <strong>per contribution</strong> under a hard hurdle with whole-return sharing. For each subscription,
              fees apply only if the realized return exceeds the hurdle rate. When this occurs, the
               investor retains the greater of the hurdle rate or 75% of the total return, with the
                fund receiving the balance. If performance falls below the hurdle, no performance
                 fee is charged. This contribution-based structure ensures that new investments are never
                  charged on performance earned before their entry, while the hard hurdle provides
                   investors with downside protection and aligns compensation with realized results.
                   <br><br>
                   On the right, contributions are shown as negative cash flows at their dates; the terminal portfolio value
                   (latest NAV in the selected window) is shown as a positive cash flow. 
        </p>
    </div>

    <div class="chart-container">
      <h4>Your Contributions Chart</h4>
      <div class="chart-area" style="height:320px;">
        <canvas id="cashFlowChart"></canvas>
      </div>
    </div>
  </div>
  <!--Thirs row: Projection -->
  <div class="fund-wrapper">
    <div class="fund-info">
      <h4 class="fw-bold mb-3">Forward Curve Trading Projection</h4>
      
        <p class="text-muted text-justify mt-3">
          As a forward-curve trading fund, our core strategy is implemented through calendar spreads. 
          This approach does not rely on outright directional bets on commodity prices, but rather on the
           relative value between different maturities along the curve. Because spreads tend to mean-revert
            and exhibit more stable dynamics than flat price movements, the strategy allows us to project fund
             performance with greater confidence. For investors, this means that your current account balance
              is not static: it is expected to grow over time at the projected rate implied by existing forward
               positions. While these projections are subject to market conditions and risk management adjustments,
                they provide a transparent view of the growth trajectory to which your capital is currently exposed.<br><br>
                The chart on the right illustrates how we expect your current account to evolve under the fund’s 
                forward curve calendar spread strategy, shown net of all management and performance fees.
        </p>
    </div>

    <div class="chart-container">
      <h4>Projection Chart</h4>
      <div class="chart-area" style="height:320px;">
        <canvas id="ProjectionChart"></canvas>
      </div>
    </div>
  </div>
</section>


<!-- Chart.js & Moment.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>

<script>
let fundChart;
let cashFlowChart;
let seriesNames = [];
const EXTRA_SERIES_KEY = "Fund (After Fee)";
let selectedSeries = new Set();  // which series user wants visible
let fundPayload; // was missing in your globals
let projectionChart;
/** Fetch rebased series from Python */
async function loadFundSeries(startStr, endStr) {
  const url = `/api/fund-series?start=${encodeURIComponent(startStr)}&end=${encodeURIComponent(endStr)}`;
  const r = await fetch(url, { cache: 'no-store' });
  if (!r.ok) throw new Error(`API error ${r.status}`);
  fundPayload = await r.json();
  console.log("📦 fundPayload:", fundPayload);

  // Set globals used by UI
  seriesNames = fundPayload.series_names || [];
  if (selectedSeries.size === 0) {
    seriesNames.forEach(s => selectedSeries.add(s)); // select all by default
  }
  renderSeriesControls();
}

function renderSeriesControls() {
  const container = document.getElementById('seriesControls');

  // Hard fail if the node isn't in DOM
  if (!container) {
    console.error("renderSeriesControls: #seriesControls not found");
    return;
  }

  const allSeries = [...seriesNames];
  console.log("renderSeriesControls: allSeries =", allSeries);

  // If nothing to show, render a placeholder so the menu isn't visually empty
  if (!allSeries.length) {
    container.innerHTML = '<div class="text-muted small">No series loaded</div>';
    return;
  }

  // initialize once
  if (selectedSeries.size === 0) {
    allSeries.forEach(s => selectedSeries.add(s));
  }

  container.innerHTML = '';
  allSeries.forEach((name, idx) => {
    try {
      const id = `series-${idx}`;
      const row = document.createElement('div');
      row.className = 'form-check mb-1';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.className = 'form-check-input';
      cb.id = id;
      cb.checked = selectedSeries.has(name);
      cb.addEventListener('change', () => {
        if (cb.checked) selectedSeries.add(name);
        else selectedSeries.delete(name);
        updateChart();
      });

      const label = document.createElement('label');
      label.className = 'form-check-label';
      label.setAttribute('for', id);
      label.textContent = name;

      row.appendChild(cb);
      row.appendChild(label);
      container.appendChild(row);
    } catch (e) {
      console.error("renderSeriesControls: error for", name, e);
    }
  });

  const btnAll  = document.getElementById('seriesSelectAll');
  const btnNone = document.getElementById('seriesSelectNone');
  if (btnAll) btnAll.onclick = () => { selectedSeries = new Set(allSeries); renderSeriesControls(); updateChart(); };
  if (btnNone) btnNone.onclick = () => { selectedSeries.clear(); renderSeriesControls(); updateChart(); };
}

/** Build the chart from fundPayload + selectedSeries */
function updateChart() {
  if (!fundPayload || !Array.isArray(fundPayload.dates)) return;

  const labels = fundPayload.dates;
  const datasets = [];
  const palette = ['#0d6efd','#dc3545','#198754','#fd7e14','#6f42c1','#20c997'];

  seriesNames.forEach((name, i) => {
    if (!selectedSeries.has(name)) return;
    const arr = (fundPayload.series && fundPayload.series[name]) || [];
    datasets.push({
      label: name,
      data: arr.map(v => (v == null ? null : v * 100)),  // Python returns decimals; chart shows %
      borderWidth: 0.8,
      tension: 0.1,
      borderColor: palette[datasets.length % palette.length],
      backgroundColor: 'rgba(0,0,0,0)',
      spanGaps: true,
      pointRadius: 0.6,
      pointHoverRadius: 1
    });
  });

  const ctx = document.getElementById('fundChart').getContext('2d');
  if (fundChart) fundChart.destroy();
  fundChart = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { title: { display: true, text: 'Date' } },
        y: {
          title: { display: true, text: 'Return since start (%)' },
          ticks: { callback: v => (v ?? 0).toFixed(1) + '%' }
        }
      },
      plugins: {
        title: { display: true, text: 'Vega Core Fund — Rebased Performance (Selected Window)' },
        legend: { display: true, position: 'top' },
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y != null ? ctx.parsed.y.toFixed(2) + '%' : '—'}`
          }
        }
      }
    }
  });
}





/** Fund Chart Event Binding - */


['startDate','endDate'].forEach(id =>
  document.getElementById(id).addEventListener('change', updateChart)
);

document.addEventListener('DOMContentLoaded', async () => {
  // First fetch with no date restrictions (backend should still send Fiscal_year_start)
  const today = new Date();
  const todayStr = today.toISOString().split('T')[0];

  // Load once to discover fiscal year start from JSON
  await loadFundSeries("", todayStr);

  // Get fiscal start from payload, fallback = 6 months ago
  let fiscalStart = fundPayload.fiscal_year_start;  // always use API value

  // Prefill inputs
  document.getElementById("startDate").value = fundPayload.fiscal_year_start;;
  document.getElementById("endDate").value   = todayStr;

  // Now reload properly with fiscal start → today
  await loadFundSeries(fiscalStart, todayStr);
  updateChart();

  // ✅ Bind Update button
  document.getElementById('updateChart').addEventListener('click', async () => {
    const startStr = document.getElementById('startDate').value;
    const endStr   = document.getElementById('endDate').value;

    if (!startStr || !endStr) {
      alert("Please pick both start and end dates");
      return;
    }

    await loadFundSeries(startStr, endStr);
    updateChart();
  });
});

</script>






<!-- Chart.js -->

<script>
  /** Compensation chart - */
document.addEventListener('DOMContentLoaded', async () => {
  const compCanvas = document.getElementById('compensationChart');
  
  try {
    const resp = await fetch("/api/compensation-chart", { cache: "no-store" });
    if (!resp.ok) throw new Error("Comp chart API error " + resp.status);
    const payload = await resp.json();

    const labels = payload.Ret.map(v => v.toFixed(0) + "%");
    const investorReturn = payload.Investor;
    const fundFee = payload.Fund;

    

    new Chart(compCanvas.getContext('2d'), {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { 
            label: 'Investor Return', 
            data: investorReturn, 
            backgroundColor: 'rgba(54, 162, 235, 0.7)',
            stack: 'combined'
          },
          { 
            label: 'Fund Fee', 
            data: fundFee, 
            backgroundColor: 'rgba(255, 159, 64, 0.7)',
            stack: 'combined'
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { 
            stacked: true,
            title: { display: true, text: 'Total Return' }
          },
          y: { 
            stacked: true,
            beginAtZero: true,
            ticks: { callback: v => v + '%' }
          }
        },
        plugins: {
          legend: { position: 'top' },
          title: { display: true, text: 'Compensation vs Investor Return (Stacked)' },
          tooltip: {
            callbacks: {
              label: function(context) {
                return `${context.dataset.label}: ${context.parsed.y}%`;
              }
            }
          }
        }
      }
    });

  } catch (e) {
    console.error('Failed to load compensation.csv', e);
  }
});




</script>
<!-- ✅ New Cashflow Chart Renderer -->
<script>


const CF_DATA = {{ metrics.cashflow_chart | tojson }};

document.addEventListener('DOMContentLoaded', () => {
  console.log("🔍 Raw CF_DATA:", CF_DATA);

  const ctx = document.getElementById('cashFlowChart').getContext('2d');
  if (!CF_DATA) {
    console.warn("⚠️ No CF_DATA provided");
    return;
  }

  const contribDates = CF_DATA.contributions.map(c => c.date);
  const contribVals  = CF_DATA.contributions.map(c => (c.value));

  console.log("📅 Contribution Dates:", contribDates);
  console.log("💰 Contribution Values (negative):", contribVals);

  const term = CF_DATA.terminal || { investor_share: 0, perf_fee: 0, mgmt_fee: 0 };
  console.log("📦 Terminal block:", term);

  const labels = [...contribDates, "Terminal"];

  const data = {
    labels,
    datasets: [
      {
        label: "Contributions",
        data: [...contribVals,null],
        backgroundColor: "rgba(220,53,69,0.7)",
        stack: "contribs"
        
      },
      {
        label: "Investor Share",
        data: [...Array(contribVals.length).fill(null), term.investor_share],
        backgroundColor: "rgba(25,135,84,0.7)",
        stack: "terminal"
      },
      {
        label: "Perf Fee",
        data: [...Array(contribVals.length).fill(null), term.perf_fee],
        backgroundColor: "rgba(255,193,7,0.7)",
        stack: "terminal"
      },
      {
        label: "Mgmt Fee",
        data: [...Array(contribVals.length).fill(null), term.mgmt_fee],
        backgroundColor: "rgba(13,110,253,0.7)",
        stack: "terminal"
      }
    ]
  };

  console.log("📊 Final chart data:", data);

  new Chart(ctx, {
    type: "bar",
    data,
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        title: {
          display: true,
          text: `Cash Flow Chart (XIRR: ${(CF_DATA.xirr*100).toFixed(2)}%)`
        },
        tooltip: {
          callbacks: {
            label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y.toLocaleString()}`
          }
        }
      },
      scales: {
        x: {
          stacked: false,
          ticks: {
            align: 'center'   // 👈 helps centering tick labels
          }
        },
        y: { stacked: true }
      },
      // 👇 these two control bar thickness & centering
      datasets: {
        bar: {
          categoryPercentage: 0.1,  // default 0.8 → narrower, centered
          barPercentage: 9.9        // controls individual bar width
        }
      }
    }
  });
});


// Projection Chart
async function loadLockedInProjection() {
  const r = await fetch("/api/fund-projection", { cache: "no-store" });
  if (!r.ok) throw new Error(`Projection API error ${r.status}`);
  return await r.json();
}

function renderLockedInProjection(payload) {
  const ctx = document.getElementById("ProjectionChart").getContext("2d");

  const labels = payload.dates || [];
  const values = (payload.series && payload.series["Projection (After Fee)"]) || [];

  if (projectionChart) projectionChart.destroy();

  projectionChart = new Chart(ctx, {
    type: "line",
    data: {
      labels,
      datasets: [
        {
          label: "Projection (After Fee)",
          data: values,
          borderColor: "#0d6efd",
          borderWidth: 2,
          tension: 0.1,
          pointRadius: 3,
          pointBackgroundColor: "#0d6efd"
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { title: { display: true, text: "Date" } },
        y: {
          title: { display: true, text: "Projected Account Value" },
          ticks: { callback: v => v.toLocaleString() }
        }
      },
      plugins: {
        title: {
          display: true,
          text: `Locked-In Projection (Net After Fee, Annualized: ${(payload.locked_in_after_fee * 100).toFixed(1)}%)`
        },
        legend: { display: true, position: "top" }
      }
    }
  });
}

// Auto-load on page load
document.addEventListener("DOMContentLoaded", async () => {
  try {
    const projData = await loadLockedInProjection();
    renderLockedInProjection(projData);
  } catch (e) {
    console.error("⚠️ Projection chart failed", e);
  }
});
</script>
{% endblock %}
